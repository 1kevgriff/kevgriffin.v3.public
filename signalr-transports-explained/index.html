<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>SignalR Transports Explained by Kevin Griffin</title><meta name="gridsome:hash" content="782414107f461c86c0093807ec9a7009f522142f"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.11"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mali:700|Nunito"><link rel="preload" href="/assets/css/0.styles.dc844d61.css" as="style"><link rel="preload" href="/assets/js/app.a597a7b1.js" as="script"><link rel="preload" href="/assets/js/page--src-templates-article-vue.fe6cfc9d.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules-gridsome-app-pages-404-vue.e4711ebb.js"><link rel="prefetch" href="/assets/js/page--src-pages-index-vue.e8d64122.js"><link rel="stylesheet" href="/assets/css/0.styles.dc844d61.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="layout"><header class="header"><a href="/" class="heading-link active"><h6 class="heading"></h6></a></header><div class="article"><h1>SignalR Transports Explained</h1><span>August 17, 2015</span><div class="content"><p>When I sit down to talk to people about SignalR, a common discussion we have is around transports and what the difference between them are.  While SignalR gives you the flexibility to choose your own transport, it is often a better bet to simply allow the library to choose for you.</p>
<h2 id="how-does-signalr-determine-which-transport-to-use"><a href="#how-does-signalr-determine-which-transport-to-use" aria-hidden="true"><span class="icon icon-link"></span></a>How does SignalR determine which transport to use?</h2>
<p>There are two pieces of the puzzle that need to be evaluated before a transport is chosen.  The <strong>client</strong> and the <strong>server</strong>.  Keep in mind, a SignalR client can be something other than JavaScript.. and the server can be something not running on IIS.  </p>
<p>If you <a href="http://www.asp.net/signalr/overview/getting-started/introduction-to-signalr#transports" target="_blank" rel="nofollow noopener noreferrer">head over to SignalR documentation</a>, they provide a really great overview on how SignalR chooses a transport.</p>
<p>A simple way to explain the process is this:  </p>
<ol>
<li>If you're using legacy browser (IE8 or later.. <em>cough</em>)... use Long Polling.  </li>
<li>Do you need JSONP support?  Yes?  Long polling, for you.</li>
<li>
<p>Okay okay.  Let's try Websockets!  This works well IF:</p>
<ul>
<li>You're not doing JSONP</li>
<li>You're not going cross-domain</li>
<li>You ARE going cross-domain AND client supports CORS (Cross-Origin Resource Sharing).</li>
<li>Client supports WebSockets <strong>(IE10+, Chrome, Firefox, Safari, etc)</strong></li>
<li>Server supports WebSockets <strong>(IIS 8.0+ or self-hosted SignalR)</strong></li>
</ul>
</li>
<li>No WebSockets?  Sorry.  Give Server Sent Events a try (most likely on non-IE browsers).</li>
<li>No SSE?  Try Forever Frame (IE browsers).</li>
<li>No FF? MORE LONG POLLING!</li>
</ol>
<h2 id="what-are-the-pros-and-cons-of-each-transport-type"><a href="#what-are-the-pros-and-cons-of-each-transport-type" aria-hidden="true"><span class="icon icon-link"></span></a>What are the pros and cons of each transport type?</h2>
<p>Excellent question!  Let's walk through the list worse-case to best-case.</p>
<h3 id="long-polling"><a href="#long-polling" aria-hidden="true"><span class="icon icon-link"></span></a>Long Polling</h3>
<p>Long polling is a game of hurry up and wait.  During this process, you are opening up a pipe (AJAX call) for the server to use for possible future communication.  Anytime the server needs to send a message, the existing connection can be used.</p>
<p>However, when a connection is used, the connection is closed.  In order to continue communicating with the server, a client will need to reestablish the connection.  In a best case scenario, the server is continuously sending data, so a connection is always reestablishing.  Worse case, the connection stands open for up to two minutes (default timeout on most browsers).  The process of continuously opening and closing connections can be a bit of a strain on the server.</p>
<p>Long polling works well on old browsers, including some browsers which should have died ten years ago.  This is the final fallback position if no other acceptable transport can be used.</p>
<h3 id="forever-frame"><a href="#forever-frame" aria-hidden="true"><span class="icon icon-link"></span></a>Forever Frame</h3>
<p>Warning: Forever Frame (FF) is Internet Explorer only, but it's really interesting how this process works.  When a connection is established with FF, a hidden Iframe is created on the page.  However, the page loaded into the Iframe is special.  The connection will never closed.</p>
<p>Since the connection remains open forever, the server can use it to continuously send new script.  These scripts are loaded and executed on the parent page.  </p>
<p>Any client to server communication needs to be done the traditional way, via AJAX calls.</p>
<h3 id="server-sent-events"><a href="#server-sent-events" aria-hidden="true"><span class="icon icon-link"></span></a>Server Sent Events</h3>
<p>Some technologies stand the test of time, and Server Sent Events (SSE) is a great example.  SSE is a server to client communication protocol developed in the Netscape days.  It creates an object called an EventSource, which is a pipe from the server to the client.  Anytime the server needs to send data, the EventSource pipe can be used.  </p>
<p>SSE is supported on all browsers, except Internet Explorer (sorry, but you have Forever Frame).  Just as Forever Frame, if the client needs to communicate back with the server, a traditional AJAX call will need to be made.</p>
<h3 id="websockets"><a href="#websockets" aria-hidden="true"><span class="icon icon-link"></span></a>WebSockets</h3>
<p>Holy.  Grail.  Seriously.  There is nothing better than WebSockets.  When a WebSocket connection is made, there is a one-to-one connection between the client and server.  Both are capable of communicating on the existing pipe.  </p>
<p>Of course, you are technically limited by the browser and server being used for a connection.  Internet Explorer 9 and older need not apply (IE10+ are the only versions with WebSockets support).  Firefox, Chrome, and Safari generally have no problems.</p>
<p>For .NET folks deploying to IIS, you better be sure you are using IIS version 8 (or greater).  IIS7 did not have support for WebSockets.</p>
<h2 id="pulling-it-all-together"><a href="#pulling-it-all-together" aria-hidden="true"><span class="icon icon-link"></span></a>Pulling It All Together</h2>
<p>As you look at the various transports available, you should start to appreciate what SignalR is doing for you underneath the scenes.  What would happen if you had to implement all these different scenarios yourself?</p>
</div></div></div>
    <script>window.__INITIAL_STATE__={"data":{"article":{"id":"2e11ee70106b710eed384e31d4fd9c12","title":"SignalR Transports Explained","date":"August 17, 2015","categories":["Development - ASP.NET"],"permalink":"signalr-transports-explained","content":"\u003Cp\u003EWhen I sit down to talk to people about SignalR, a common discussion we have is around transports and what the difference between them are.  While SignalR gives you the flexibility to choose your own transport, it is often a better bet to simply allow the library to choose for you.\u003C\u002Fp\u003E\n\u003Ch2 id=\"how-does-signalr-determine-which-transport-to-use\"\u003E\u003Ca href=\"#how-does-signalr-determine-which-transport-to-use\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EHow does SignalR determine which transport to use?\u003C\u002Fh2\u003E\n\u003Cp\u003EThere are two pieces of the puzzle that need to be evaluated before a transport is chosen.  The \u003Cstrong\u003Eclient\u003C\u002Fstrong\u003E and the \u003Cstrong\u003Eserver\u003C\u002Fstrong\u003E.  Keep in mind, a SignalR client can be something other than JavaScript.. and the server can be something not running on IIS.  \u003C\u002Fp\u003E\n\u003Cp\u003EIf you \u003Ca href=\"http:\u002F\u002Fwww.asp.net\u002Fsignalr\u002Foverview\u002Fgetting-started\u002Fintroduction-to-signalr#transports\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehead over to SignalR documentation\u003C\u002Fa\u003E, they provide a really great overview on how SignalR chooses a transport.\u003C\u002Fp\u003E\n\u003Cp\u003EA simple way to explain the process is this:  \u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EIf you're using legacy browser (IE8 or later.. \u003Cem\u003Ecough\u003C\u002Fem\u003E)... use Long Polling.  \u003C\u002Fli\u003E\n\u003Cli\u003EDo you need JSONP support?  Yes?  Long polling, for you.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EOkay okay.  Let's try Websockets!  This works well IF:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EYou're not doing JSONP\u003C\u002Fli\u003E\n\u003Cli\u003EYou're not going cross-domain\u003C\u002Fli\u003E\n\u003Cli\u003EYou ARE going cross-domain AND client supports CORS (Cross-Origin Resource Sharing).\u003C\u002Fli\u003E\n\u003Cli\u003EClient supports WebSockets \u003Cstrong\u003E(IE10+, Chrome, Firefox, Safari, etc)\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EServer supports WebSockets \u003Cstrong\u003E(IIS 8.0+ or self-hosted SignalR)\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003ENo WebSockets?  Sorry.  Give Server Sent Events a try (most likely on non-IE browsers).\u003C\u002Fli\u003E\n\u003Cli\u003ENo SSE?  Try Forever Frame (IE browsers).\u003C\u002Fli\u003E\n\u003Cli\u003ENo FF? MORE LONG POLLING!\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"what-are-the-pros-and-cons-of-each-transport-type\"\u003E\u003Ca href=\"#what-are-the-pros-and-cons-of-each-transport-type\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EWhat are the pros and cons of each transport type?\u003C\u002Fh2\u003E\n\u003Cp\u003EExcellent question!  Let's walk through the list worse-case to best-case.\u003C\u002Fp\u003E\n\u003Ch3 id=\"long-polling\"\u003E\u003Ca href=\"#long-polling\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ELong Polling\u003C\u002Fh3\u003E\n\u003Cp\u003ELong polling is a game of hurry up and wait.  During this process, you are opening up a pipe (AJAX call) for the server to use for possible future communication.  Anytime the server needs to send a message, the existing connection can be used.\u003C\u002Fp\u003E\n\u003Cp\u003EHowever, when a connection is used, the connection is closed.  In order to continue communicating with the server, a client will need to reestablish the connection.  In a best case scenario, the server is continuously sending data, so a connection is always reestablishing.  Worse case, the connection stands open for up to two minutes (default timeout on most browsers).  The process of continuously opening and closing connections can be a bit of a strain on the server.\u003C\u002Fp\u003E\n\u003Cp\u003ELong polling works well on old browsers, including some browsers which should have died ten years ago.  This is the final fallback position if no other acceptable transport can be used.\u003C\u002Fp\u003E\n\u003Ch3 id=\"forever-frame\"\u003E\u003Ca href=\"#forever-frame\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EForever Frame\u003C\u002Fh3\u003E\n\u003Cp\u003EWarning: Forever Frame (FF) is Internet Explorer only, but it's really interesting how this process works.  When a connection is established with FF, a hidden Iframe is created on the page.  However, the page loaded into the Iframe is special.  The connection will never closed.\u003C\u002Fp\u003E\n\u003Cp\u003ESince the connection remains open forever, the server can use it to continuously send new script.  These scripts are loaded and executed on the parent page.  \u003C\u002Fp\u003E\n\u003Cp\u003EAny client to server communication needs to be done the traditional way, via AJAX calls.\u003C\u002Fp\u003E\n\u003Ch3 id=\"server-sent-events\"\u003E\u003Ca href=\"#server-sent-events\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EServer Sent Events\u003C\u002Fh3\u003E\n\u003Cp\u003ESome technologies stand the test of time, and Server Sent Events (SSE) is a great example.  SSE is a server to client communication protocol developed in the Netscape days.  It creates an object called an EventSource, which is a pipe from the server to the client.  Anytime the server needs to send data, the EventSource pipe can be used.  \u003C\u002Fp\u003E\n\u003Cp\u003ESSE is supported on all browsers, except Internet Explorer (sorry, but you have Forever Frame).  Just as Forever Frame, if the client needs to communicate back with the server, a traditional AJAX call will need to be made.\u003C\u002Fp\u003E\n\u003Ch3 id=\"websockets\"\u003E\u003Ca href=\"#websockets\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EWebSockets\u003C\u002Fh3\u003E\n\u003Cp\u003EHoly.  Grail.  Seriously.  There is nothing better than WebSockets.  When a WebSocket connection is made, there is a one-to-one connection between the client and server.  Both are capable of communicating on the existing pipe.  \u003C\u002Fp\u003E\n\u003Cp\u003EOf course, you are technically limited by the browser and server being used for a connection.  Internet Explorer 9 and older need not apply (IE10+ are the only versions with WebSockets support).  Firefox, Chrome, and Safari generally have no problems.\u003C\u002Fp\u003E\n\u003Cp\u003EFor .NET folks deploying to IIS, you better be sure you are using IIS version 8 (or greater).  IIS7 did not have support for WebSockets.\u003C\u002Fp\u003E\n\u003Ch2 id=\"pulling-it-all-together\"\u003E\u003Ca href=\"#pulling-it-all-together\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPulling It All Together\u003C\u002Fh2\u003E\n\u003Cp\u003EAs you look at the various transports available, you should start to appreciate what SignalR is doing for you underneath the scenes.  What would happen if you had to implement all these different scenarios yourself?\u003C\u002Fp\u003E\n"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.a597a7b1.js" defer></script><script src="/assets/js/page--src-templates-article-vue.fe6cfc9d.js" defer></script>
  </body>
</html>
