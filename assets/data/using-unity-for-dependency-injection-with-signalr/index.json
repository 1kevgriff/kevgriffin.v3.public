{"hash":"782414107f461c86c0093807ec9a7009f522142f","data":{"article":{"id":"2de519b93eefb07cdbbfa81389f9b993","title":"Using Unity for Dependency Injection with SignalR","date":"January 08, 2013","categories":["Development - ASP.NET"],"permalink":"using-unity-for-dependency-injection-with-signalr","content":"<p>I've had bit of a day, and a large part of it was learning how to wrangle SignalR into using my dependency injection provider (in this case, being Unity).  There are a couple thoughts, that I'd like to communicate to you all in case you're looking to do the same thing.  Also, if you have suggestions on what I could do differently, I'm more than open to hearing.  This is solution that worked for me, and I'm hoping it'll work for you.</p>\n<p><strong>NOTE: This is built using SignalR v1.0-RC, which is a Prerelease NuGet package.  I'll try to update if this changes after release.</strong></p>\n<p>First, what do we want to do?</p>\n<pre lang=\"csharp\">public class MyHub : Hub\n{\n   public MyHub(ISomeInterface interface)\n   {\n      // handle constructor injection here\n   }\n}</pre>\n<p>There's a hub, but it doesn't have a default constructor.  I'd like to be able to have SignalR automatically INJECT the constructor requirements when we load a new instance of the Hub.</p>\n<p>There are TWO things we need to do.  First, we need to build our container (with Unity) and tell SignalR to use it.</p>\n<pre lang=\"csharp\">        public static void Initialise() // this isn't my misspelling, it's in the Unity.MVC NuGet package.\n        {\n            var container = BuildUnityContainer();\n\n            var unityDependencyResolver = new UnityDependencyResolver(container);\n\n            // used for MVC\n            DependencyResolver.SetResolver(unityDependencyResolver);\n            // used for WebAPI\n            GlobalConfiguration.Configuration.DependencyResolver = new Unity.WebApi.UnityDependencyResolver(container);\n            // used for SignalR\n            GlobalHost.DependencyResolver = new SignalRUnityDependencyResolver(container);\n        }\n\n        private static IUnityContainer BuildUnityContainer()\n        {\n            var container = new UnityContainer();\n\n            // register all your dependencies here.\n            container.RegisterType&lt;ISomeInterface, SomeInterface&gt;();\n\n            return container;\n        }</pre>\n<p>Simple enough. You might want to know what SignalRUnityDependencyResolver looks like:</p>\n<pre lang=\"csharp\">public class SignalRUnityDependencyResolver : DefaultDependencyResolver\n    {\n        private IUnityContainer _container;\n\n        public SignalRUnityDependencyResolver(IUnityContainer container)\n        {\n            _container = container;\n        }\n\n        public override object GetService(Type serviceType)\n        {\n            if (_container.IsRegistered(serviceType)) return _container.Resolve(serviceType);\n            else return base.GetService(serviceType);\n        }\n\n        public override IEnumerable&lt;object&gt; GetServices(Type serviceType)\n        {\n            if (_container.IsRegistered(serviceType)) return _container.ResolveAll(serviceType);\n            else return base.GetServices(serviceType);\n        }\n\n    }</pre>\n<p>What's going on here? We're creating a new SignalR dependency resolver, and inheriting from the default dependency resolver that SignalR uses. When SignalR goes to resolve a dependency, we're first going to ask Unity if it has an existing implementation. If it does not, we pass the request on to SignalR to get its default (if one is available).</p>\n<p>Why do we have do this? First, you can just replace the IoC container altogether, but I have had no luck registering all the various types that SignalR uses. This was by far an easier approach.</p>\n<p>You'd like to think everything will just work now, right? Wrong. The dependencies in your hub still will not injected. My understanding is that this is by design, so here's how to work with it.</p>\n<pre lang=\"csharp\" class=\"crayon-selected\">private static IUnityContainer BuildUnityContainer()\n        {\n            var container = new UnityContainer();\n\n            container.RegisterType&lt;ISomeInterface, SomeInterface&gt;();\n            container.RegisterType&lt;MyHub&gt;(new InjectionFactory(CreateMyHub));\n\n            return container;\n        }\n\n        private static object CreateMyHub(IUnityContainer p)\n        {\n            var myHub= new MyHub(p.Resolve&lt;ISomeInterface&gt;());\n\n            return myHub;\n        }</pre>\n<p>This should be simple to follow. I'm registering a new type: MyHub, and telling Unity how to create a new instance of it. Creating it involves resolving the interface myself, and creating the new instance. This instance gets routed through SignalR and eventually executed.</p>\n<p>I'm also a user of StructureMap and Ninject, and I need to sit down to figure out this same process with those frameworks (if I even need to).  If you already have experience with them, let me know what you did.</p>\n"}},"context":{}}